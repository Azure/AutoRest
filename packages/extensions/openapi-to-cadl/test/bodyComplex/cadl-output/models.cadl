import "@cadl-lang/rest";

using Cadl.Rest;

namespace AutoRestComplexTestService;

enum CMYKColors {
  "cyan",
  "Magenta",
  "YELLOW",
  "blacK",
}

enum MyKind {
  "Kind1",
}

enum GoblinSharkColor {
  "pink",
  "gray",
  "brown",
  @doc("Uppercase RED") upperRed: "RED",
  @doc("Lowercase RED") lowerRed: "red",
}

model basic {
  @doc("Basic Id")
  id?: int32;

  @doc("""
Name property with a very long description that does not fit on a single line
and a line break.
""")
  name?: string;
  color?: CMYKColors;
}

@error
model Error {
  status?: int32;
  message?: string;
}

model int_wrapper {
  field1?: int32;
  field2?: int32;
}

model long_wrapper {
  field1?: int32;
  field2?: int32;
}

model float_wrapper {
  field1?: float32;
  field2?: float32;
}

model double_wrapper {
  field1?: float32;
  field_56_zeros_after_the_dot_and_negative_zero_before_dot_and_this_is_a_long_field_name_on_purpose?: float32;
}

model boolean_wrapper {
  field_true?: boolean;
  field_false?: boolean;
}

model string_wrapper {
  field?: string;
  empty?: string;
  null?: string;
}

model date_wrapper {
  field?: plainDate;
  leap?: plainDate;
}

model datetime_wrapper {
  field?: zonedDateTime;
  now?: zonedDateTime;
}

model datetimerfc1123_wrapper {
  field?: zonedDateTime;
  now?: zonedDateTime;
}

model duration_wrapper {
  field?: duration;
}

model byte_wrapper {
  field?: bytes;
}

model array_wrapper {
  array?: string[];
}

model dictionary_wrapper {
  @doc("Dictionary of <string>")
  defaultProgram?: Record<string>;
}

model siamese {
  ...cat;
  breed?: string;
}

model cat {
  ...pet;
  color?: string;
  hates?: dog[];
}

model dog {
  ...pet;
  food?: string;
}

model pet {
  id?: int32;
  name?: string;
}

@discriminator("fishtype")
model Fish {
  species?: string;
  // FIXME: (resource-key-guessing) - Verify that this property is the resource key, if not please update the model with the right one

  @key
  length: float32;
  siblings?: Fish[];
}

@discriminator("fish.type")
model DotFish {
  species?: string;
}

model DotFishMarket {
  sampleSalmon?: DotSalmon;
  salmons?: DotSalmon[];
  sampleFish?: DotFish;
  fishes?: DotFish[];
}

model DotSalmon extends DotFish {
  location?: string;
  iswild?: boolean;
  "fish.type": "DotSalmon";
}

@discriminator("fishtype")
model salmon extends Fish {
  location?: string;
  iswild?: boolean;
}

model readonly_obj {
  @visibility("read")
  id?: string;
  size?: int32;
}

@discriminator("kind")
model MyBaseType {
  propB1?: string;
  helper?: MyBaseHelperType;
}

model MyBaseHelperType {
  propBH1?: string;
}

model smart_salmon extends salmon {
  college_degree?: string;
  fishtype: "smart_salmon";
}

@discriminator("fishtype")
model shark extends Fish {
  age?: int32;
  birthday: zonedDateTime;
}

model sawshark extends shark {
  picture?: bytes;
  fishtype: "sawshark";
}

model goblinshark extends shark {
  jawsize?: int32;

  @doc("Colors possible")
  color?: GoblinSharkColor;
  fishtype: "goblin";
}

model cookiecuttershark extends shark {
  fishtype: "cookiecuttershark";
}

model MyDerivedType extends MyBaseType {
  propD1?: string;
  kind: "Kind1";
}
