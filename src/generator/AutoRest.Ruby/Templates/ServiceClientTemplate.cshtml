@using AutoRest.Ruby.Templates
@using System.Linq
@using AutoRest.Ruby
@inherits AutoRest.Core.Template<AutoRest.Ruby.TemplateModels.ServiceClientTemplateModel>
# encoding: utf-8
@Header("# ")
@EmptyLine
module @Settings.Namespace
  #
  # A service client - single point of access to the REST API.
  #
  class @Model.Name < @Model.BaseType

@foreach (var include in Model.Includes)
{
    @:include @include
}
    @Model.IncludeSerializer
    @EmptyLine

    # @@return [String] the base URI of the service.
    @(Model.IsCustomBaseUri ? "attr_reader" : "attr_accessor") :base_url
@EmptyLine

@foreach (var property in Model.Properties)
{
    @:@WrapComment("# ", string.Format("@return {0}{1}", property.Type.GetYardDocumentation(), property.Documentation))
    @:@(property.IsReadOnly ? "attr_reader" : "attr_accessor") :@property.Name
@EmptyLine
}

@foreach (var operation in Model.MethodGroups)
{
    @:@WrapComment("# ", string.Format("@return [{0}] {1}", operation, RubyCodeNamer.UnderscoreCase(operation)))
    @:attr_reader :@(RubyCodeNamer.UnderscoreCase(operation))
@EmptyLine
}

    #
    # Creates initializes a new instance of the @Model.Name class.
    # @@param credentials [MsRest::ServiceClientCredentials] credentials to authorize HTTP requests made by the service client.
    @if (!Model.IsCustomBaseUri)
    {
    @:# @@param base_url [String] the base URI of the service.
    }
    # @@param options [Array] filters to be applied to the HTTP requests.
    #
    @if (!Model.IsCustomBaseUri)
    {
    @:def initialize(credentials, base_url = nil, options = nil)
    }
    else
    {
    @:def initialize(credentials, options = nil)
    }
      super(credentials, options)
      @if (!Model.IsCustomBaseUri)
      {
      @:@@base_url = base_url || '@Model.BaseUrl'
      }
      else
      {
      @:@@base_url = '@Model.BaseUrl'
      }
      @EmptyLine
      fail ArgumentError, 'credentials is nil' if credentials.nil?
      fail ArgumentError, 'invalid type of credentials input parameter' unless credentials.is_a?(MsRest::ServiceClientCredentials)
      @@credentials = credentials
      @EmptyLine
      @foreach (var operation in Model.MethodGroups)
      {
      @:@@@(RubyCodeNamer.UnderscoreCase(operation)) = @(operation).new(self)
      }

      @foreach (var property in Model.Properties.Where(p => p.DefaultValue != null))
      {
      @:@@@(property.Name) = @(property.DefaultValue)
      }
    end

    @EmptyLine
    #
    # Makes a request and returns the body of the response
    # @@param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete   
    # @@param path [String] the path, relative to {api_endpoint}
    # @@param options [Hash{String=>String}] specifying any request options like :body
    # @@return [Hash{String=>String}] containing the body of the response
    #
    def make_request(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
    end
    @EmptyLine

    #
    # Makes a request asynchronously
    # @@param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete
    # @@param path [String] the path, relative to {api_endpoint}
    # @@param options [Hash{String=>String}] specifying any request options like :body
    # @@return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def make_request_async(method, path, options = {})
      fail ArgumentError, 'method is nil' if method.nil?
      fail ArgumentError, 'path is nil' if path.nil?

      @EmptyLine
      request_headers= REQUEST_HEADERS
      request_headers.merge!({'accept-language': @@accept_language}) unless @@accept_language.nil?

      @EmptyLine
      request_url= options[:api_endpoint] || @@base_url
      
      @EmptyLine
      options=options.merge({
        headers: request_headers.merge(options[:headers] || {})
      })
      options.merge!({credentials: @@credentials}) unless @@credentials.nil?

      @EmptyLine
      super(request_url, method, path, options)
    end
    
    @EmptyLine
    #
    # Makes a request asynchronously
    # @@param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete
    # @@param path [String] the path, relative to {api_endpoint}
    # @@param options [Hash{String=>String}] specifying any request options like :body
    # @@return [@(Model.OperationResponseString)] Operation response containing the request, response and status
    #
    def make_request_with_http_info(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.body = result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
      result
    end

    @EmptyLine
    @foreach (var method in Model.MethodTemplateModels)
    {
    @:@(Include(new MethodTemplate(), method))
    @EmptyLine
    @:
    }
  end
end
