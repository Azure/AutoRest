@using System.Collections.Generic;
@using System.Linq;
@using System.Text;
@using System;
@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Model

@inherits AutoRest.Core.Template<AutoRest.Go.Model.MethodGo>

@{
    List<string> pd = Model.PrepareDecorators;
    List<string> rd = Model.RespondDecorators;
    rd.Insert(0, "resp");
}

@if (Model.IsNextMethod)
{
@WrapComment("// ", "Next " + Model.Description.ToSentence())
@://
}
else
{
@WrapComment("// ", Model.Name + " " + Model.Description.ToSentence())
@://
}
@if (Model.LocalParameters.Count() > 0)
{
@WrapComment("// ", Model.ParametersDocumentation)
@://
}
@if (Model.IsNextMethod)
{
@:func (lastResults @(Model.ReturnValue().Body.Name)) Next(@Model.MethodParametersSignature(Model.IsNextMethod)) (@Model.MethodReturnSignature(false)) {
}
else
{
@:func (client @(Model.Owner)) @(Model.MethodSignature) (@Model.MethodReturnSignature(false)) {
@if (Model.ReturnViaChannel)
{
    @:resultChan := make(chan @(Model.MethodReturnType), 1)
    @:errChan:= make(chan error, 1)
}
}
@if (Model.ParameterValidations.Length > 0)
{
    @:if err := validation.Validate([]validation.Validation{
    @:@(Model.ParameterValidations)}); err != nil {
    @if (Model.ReturnViaChannel)
    {
    @:errChan <- @(Model.ValidationError)
    @:close(errChan)
    @:close(resultChan)
    @:return resultChan, errChan
    }
    else
    {
    @:return result, @(Model.ValidationError)
    }
@:}
@:@EmptyLine
}
@if (Model.ReturnViaChannel)
{
    @:go func() {
        @:var err error
        @:var result @(Model.MethodReturnType)

        @:defer func() {
            @:resultChan <- result
            @:errChan <- err
            @:close(resultChan)
            @:close(errChan)
        @:}()
}
    @if (Model.IsNextMethod)
    {
    @:req, err := lastResults.NextPreparer(@(Model.HelperInvocationParameters(Model.IsNextMethod)))
    }
    else
    {
    @:req, err := client.@(Model.PreparerMethodName)(@(Model.HelperInvocationParameters(Model.IsNextMethod)))
    }
    if err != nil {
        err = @(Model.AutorestError("Failure preparing request"))
        return
    }

    @EmptyLine
    @if (Model.IsNextMethod)
    {
    @:resp, err := lastResults.NextSender(req)
    }
    else
    {
    @:resp, err := client.@(Model.SenderMethodName)(req)
    }
    if err != nil {
        @(Model.Response)
        err = @(Model.AutorestError("Failure sending request", "resp"))
        return
    }

    @EmptyLine
    @if (Model.IsNextMethod)
    {
    @:result, err = lastResults.NextResponder(resp)
    }
    else
    {
    @:result, err = client.@(Model.ResponderMethodName)(resp)
    }
    if err != nil {
        err = @(Model.AutorestError("Failure responding to request", "resp"))
    }
@if (Model.ReturnViaChannel)
{
    @:}()
    @:return resultChan, errChan
}
else
{
    @EmptyLine
    @:return
}
}

@EmptyLine
@if (Model.IsNextMethod)
{
@:// NextPreparer prepares a request to retrieve the next set of @(Model.Name).
@:func (lastResults @(Model.ReturnValue().Body.Name)) NextPreparer(@(Model.MethodParametersSignature(Model.IsNextMethod))) (*http.Request, error) {
}
else
{
@:// @(Model.PreparerMethodName) prepares the @(Model.Name) request.
@:func (client @(Model.Owner)) @(Model.PreparerMethodName)(@(Model.MethodParametersSignature(Model.IsNextMethod))) (*http.Request, error) {
}
@if (Model.IsCustomBaseUri && Model.URLParameters.Any())
{
    @:@(Model.URLMap)
    @:@EmptyLine
}
@if (Model.PathParameters.Any())
{
    @:@(Model.PathMap)
    @:@EmptyLine
}
@if (Model.QueryParameters.Any())
{
    @if (Model.QueryParameters.Any(p => p.GetParameterName().IsApiVersion())
        && !Model.LocalParameters.Any(p => p.GetParameterName().IsApiVersion())) 
    {
        @:@(string.Format("const APIVersion = \"{0}\"", Model.APIVersion))
    }
    @:@(Model.QueryMap)
    foreach (var p in Model.OptionalQueryParameters)
    {
    @:if @(p.ModelType.GetEmptyCheck(p.GetParameterName(),false)) {
        @:@(p.AddToMap("queryParameters", Model.IsNextMethod, Model.NextLink))
    @:}
    }
    @:@EmptyLine
}

@if (Model.FormDataParameters.Any())
{
    @:@(Model.FormDataMap)
    @:@EmptyLine
}


    preparer := autorest.CreatePreparer(
                        @(pd.EmitAsArguments()))

@if (Model.BodyParameter != null && !Model.BodyParameter.IsRequired)
{
    @:if @(Model.BodyParameter.ModelType.GetEmptyCheck(Model.BodyParameter.Name, false)) {
        @:preparer = autorest.DecoratePreparer(preparer,
                            @:@(string.Format("autorest.WithJSON({0})", Model.BodyParameter.Name)))
    @:}
}

@foreach (var p in Model.OptionalHeaderParameters)
    {
    @:if @(p.ModelType.GetEmptyCheck(p.GetParameterName(), false)) {
        @:preparer = autorest.DecoratePreparer(preparer,
                            @:@(string.Format("autorest.WithHeader(\"{0}\",autorest.String({1}))",
                            p.SerializedName, p.GetParameterName())))
    @:}
}

    @(Model.IsLongRunningOperation()
        ? "return preparer.Prepare(&http.Request{Cancel: cancel})"
        : "return preparer.Prepare(&http.Request{})")
}


@EmptyLine
@if (Model.IsNextMethod)
{
@:// NextSender sends the next results request to get the next set of results
@:// of @(Model.Name). The method will close the http.Response Body if it
@://receives an error.
@:func (lastResults @(Model.ReturnValue().Body.Name)) NextSender(req *http.Request) (*http.Response, error) {
}
else
{
@:// @(Model.SenderMethodName) sends the @(Model.Name) request. The method will close the
@:// http.Response Body if it receives an error.
@:func (client @(Model.Owner)) @(Model.SenderMethodName)(req *http.Request) (*http.Response, error) {
}
    @if (Model.IsLongRunningOperation())
    {
        @if (Model.IsNextMethod)
        {
        @:return autorest.SendWithSender(lastResults.client,
        }
        else
        {
        @:return autorest.SendWithSender(client,
        }
                                                    @:req,
                                                    @:azure.DoPollForAsynchronous(client.PollingDelay))
    }
    else
    {
    @if (Model.IsNextMethod)
    {
    @:return autorest.SendWithSender(lastResults.client, req)
    }
    else
    {
    @:return autorest.SendWithSender(client, req)
    }
    }
}

@EmptyLine
@if (Model.IsNextMethod)
{
@:// NextResponder handles the response to the next results of @(Model.Name) request. The
@:// method always closes the http.Response Body.
@:func (lastResults @(Model.ReturnValue().Body.Name)) NextResponder(resp *http.Response) (@(Model.MethodReturnSignature(true))) { 
}
else
{
@:// @(Model.ResponderMethodName) handles the response to the @(Model.Name) request. The method always
@:// closes the http.Response Body.
@:func (client @(Model.Owner)) @(Model.ResponderMethodName)(resp *http.Response) (@(Model.MethodReturnSignature(true))) { 
}
    @if (Model.ReturnValue().Body.IsStreamType())
    {
    @:result.Value = &resp.Body
    }
    err = autorest.Respond(
            @(rd.EmitAsArguments()))

    @(Model.Response)
    @if (Model.IsPageable)
    {
        
    @if (Model.IsNextMethod)
    {
    @:result.client = lastResults.client
    }
    else
    {
    @if (Model.Owner == "ManagementClient")
    {
    @:result.client = client
    }
    else
    {
    @:result.client = client.ManagementClient
    }
    }
    }
    return
}

@if (Model.IsPageable && !Model.IsNextMethod && Model.ListElement != null)
{
@:@EmptyLine
@:// @(Model.ListCompleteMethodName) gets all elements from the list without paging.
@:func (client @(Model.Owner)) @(Model.ListCompleteMethodName) @(Model.MethodParametersSignatureComplete) @(Model.MethodReturnSignatureComplete) {
    @:respSlice := @((Model.ListElement.ModelType as SequenceTypeGo).Name){}
    @:list, err := client.@(Model.Name)(@(Model.HelperInvocationParameters(Model.IsNextMethod)))
    @:if err != nil {
        @:return respSlice, err
    @:}
    @:if list.@(Model.ListElement.Name) != nil {
        @:for _, item := range *list.@(Model.ListElement.Name) {
            @:respSlice = append(respSlice, item)
        @:}
    @:}
    @:for list.@(Model.NextLink) != nil {
        @:select {
        @:case <- cancel:
            @:return respSlice, nil
        @:default:
            @:list, err = list.Next()
            @:if err != nil {
                @:return respSlice, err
            @:}            
            @:if list.@(Model.ListElement.Name) != nil {
                @:for _, item := range *list.@(Model.ListElement.Name) {
                    @:respSlice = append(respSlice, item)
                @:}
            @:}
        @:}
    @:}
    @:return respSlice, err
@:}
}
