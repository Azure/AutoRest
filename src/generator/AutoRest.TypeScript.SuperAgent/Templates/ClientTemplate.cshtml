@using System.Linq
@using System.Net
@using AutoRest.Core.Model
@using AutoRest.TypeScript.SuperAgent.Model
@inherits AutoRest.Core.Template<CodeModelTs>

// API version: @Model.ApiVersion
// Generated by: @Model.GeneratedBy at @Model.GeneratedAt
// Tool version: @Model.GeneratorVersion

import { Promise } from 'es6-promise';
import * as request from 'superagent';

export interface IApi{
@foreach (var method in Model.Methods.Where(method => method.Responses.ContainsKey(HttpStatusCode.OK)))
{
@:    async @(method.SerializedName)(requestDto: @(method.Responses[HttpStatusCode.OK].Body.ClassName)Request) : Promise<@(method.Responses[HttpStatusCode.OK].Body.ClassName)Response>;
}
}

export class Api implements IApi {
    
    private baseUrl: string;

    public constructor(baseUrl: string){
        this.baseUrl = baseUrl;
    }

@foreach (var method in Model.Methods.Where(method => method.Responses.ContainsKey(HttpStatusCode.OK)))
{
@:    public async @(method.SerializedName)(requestDto: @(method.Responses[HttpStatusCode.OK].Body.ClassName)Request) : Promise<@(method.Responses[HttpStatusCode.OK].Body.ClassName)Response> {
@:        return new Promise<@(method.Responses[HttpStatusCode.OK].Body.ClassName)Response>((resolve, reject) => {
@:            try{
    foreach (var parameter in method.Parameters)
    {
        if (parameter.IsRequired)
        {
@:                if (requestDto.@(parameter.Name.Value) == null)
@:                {
@:                    throw new Error("Missing required parameter requestDto.@(parameter.Name.Value) when calling @(method.SerializedName)");
@:                }
        }
    }
@:                const url = this.baseUrl + '@(method.Url.Value)'@foreach (var parameter in method.Parameters.Where(p => p.Location == ParameterLocation.Path)) { @:.replace('{@(parameter.Name.Value)}', @(parameter.Name.Value))
};
@:                request.@(method.HttpMethod.ToString().ToLower())(url)
    foreach (var parameter in method.Parameters)
    {
        if (parameter.Location == ParameterLocation.Body)
        {
@:                    .send(requestDto.@(parameter.Name.Value))
        }
    }
@:                    .set('Accept', 'application/json')
@:                    .end((err, res) =>
@:                    {
@:                        err === undefined ? resolve(res as @(method.Responses[HttpStatusCode.OK].Body.ClassName)Response) : reject(err);
@:                    });
@:            }
@:            catch (e)
@:            {
@:                reject(e);
@:            }
@:        });
@:    }
}
}


