@using System.Linq
@using AutoRest.Core.Utilities
@using AutoRest.TypeScript.SuperAgent.Model
@inherits AutoRest.Core.Template<CodeModelTs>

// API version: @Model.ApiVersion
// Generated by: @Model.GeneratedBy at @Model.GeneratedAt
// Tool version: @Model.GeneratorVersion

import { Promise } from 'es6-promise';
import * as request from 'superagent';

class Url{
    protected url: string;

    public constructor(baseUrl: string){
        this.url = baseUrl;
    }

    public Url addToPath(name: string, value: string){
        this.url.replace('{'  + name +  '}', value);
        return this;
    }

    public Url addToQuery(name: string, value: string){
        this.url.replace('{'  + name +  '}', value);
        return this;
    }

    public Url add(url: string){
        this.url += url;
        return this;
    }

    public toString() : string {
        return this.url;
    }
}

abstract class BaseApi {
    readonly baseUrl: string

    protected constructor(baseUrl: string){
        if(baseUrl === undefined || baseUrl === null){
            baseUrl = "";
        }
        this.baseUrl = baseUrl;
    }

    protected newUrl(url : string){
        return new Url(this.baseUrl).add(url);
    }
}

@foreach (var group in Model.MethodGroups)
{
    var apiName = $"{group.Key.ToPascalCase().Replace("Api", "")}Api";
    var apiInterfaceName = $"I{apiName}";
@:export interface @(apiInterfaceName) {
    foreach (var tsMethod in group.Select(m => new MethodModelTs(group.Key, m)))
    {
@:    @(tsMethod.MethodName)(requestDto: @(tsMethod.RequestTypeName)) : @(tsMethod.ResponsePromiseTypeName);
    }
@:}

@:export class @(apiName) extends BaseApi implements @(apiInterfaceName) {
@:
@:    public constructor(baseUrl: string) {
@:        super(baseUrl);
@:    }
    foreach (var method in group)
    {
        var tsMethod = new MethodModelTs(group.Key, method);
        var tsParams = new ParametersModelTs(method.Parameters);

@:    public async @(tsMethod.MethodName)(requestDto: @(tsMethod.RequestTypeName)) : @(tsMethod.ResponsePromiseTypeName) {
@:        return new @(tsMethod.ResponsePromiseTypeName)((resolve, reject) => {
@:            try{
@:                requestDto.validate();
@:                var url = this.newUrl('@(method.Url)');

        foreach (var name in tsParams.ParamNamesInBody) {
@:                url.addToPath('@(name)', requestDto.@(name));
        }

        foreach (var name in tsParams.ParamNamesInQuery)
        {
@:                url.addToQuery('@(name)', requestDto.@(name));
        }

@:                request.@(method.HttpMethod.ToString().ToLower())(url.toString())
        foreach (var name in tsParams.ParamNamesInBody)
        {
@:                    .send(requestDto.@(name))
        }
@:                    .set('Accept', 'application/json')
        foreach (var name in tsParams.ParamNamesInHeader)
        {
@:                    .set('@(name)', requestDto.@(name))
        }
@:                    .end((err, res) => err === undefined ? resolve(res.body as @(tsMethod.ResponseTypeName) : reject(err));
@:            }
@:            catch (e)
@:            {
@:                reject(e);
@:            }
@:        });
@:    }
    }
}
}


