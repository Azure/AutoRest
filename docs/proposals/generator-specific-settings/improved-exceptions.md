# Supporting error status codes and customized exceptions
## The issues today
- AutoRest treats every explicitly described status code of an operation as a successful response. Error codes if any, fall under the generic bucket of `default`. There is no way to indicate specific error codes that can be expected from the service for a given operation in case of an unexpected error. 
- There is limited support for customized exceptions. An error model, `ErrorModel` returned from the service is set as the `Body` property of `ErrorModelException` class which in turn is derived from the `RestException` class. 
    - The exception information displayed does not contain information sent by the service in the `ErrorModel` object. 
    - There is no way to create meaningful exception classes themselves since they are autogenerated by AutoRest. For eg., it would be natural and user friendly if the underlying base class for the exceptions were something like `FileNotFoundException`.
    - Certain operation responses do not have a `body` parameter (eg.: HEAD operations); modeling exceptions for such operations with a `body` property is unintuitive and confusing.

## Proposed solutions
1.  Adding an extension to indicate error response codes for operations. 
    ``` json
    "responses": {
        "200": {
        "description": "",
            "schema": {
                "$ref": "#/definitions/Pet"
            }
        },
        "400": {
            "description": "Bad Request",
            "schema":{
                "$ref":"#/definitions/BadRequestErrorModel"
            },
            "x-ms-error-response":true
        },
        "404": {
            "description": "Not found error",
            "schema":{
                "$ref":"#/definitions/NotFoundErrorModel"
            },
            "x-ms-error-response":true
        },
        "default": {
            "description": "Default errors",
            "schema":{
                "$ref":"#/definitions/DefaultErrorModel"
            }
        }
    }
    ```
    AutoRest can generate code for each error status code (which is indicated by `x-ms-error-response` above) and deserialize the error model returned by the server independently.

2.  Modeling error models as throwable exception classes themselves.
    For example, if in the above example, `NotFoundError` were defined as 
    ```json
    "NotFoundError":{
        "properties":{
            "resourceName":{
            "type":"string"
            }
        }
    }
    ```
    The model would be designed as:
    ```csharp
    public partial class NotFoundError : HttpRestException
    {
        public NotFoundError()
        {

        }

        public NotFoundError(string message, string resourceName = default(string))
            : this(message, null, resourceName)
        {

        }

        public NotFoundError(string message, System.Exception innerException, string resourceName = default(string))
            : base(message, innerException)
        {

            ResourceName = resourceName;
        }

       [JsonProperty(PropertyName = "resourceName")]
        public string ResourceName { get; set; }

    }

    ```
    And the Operation would be designed as:
    ```csharp
    if ((int)_statusCode != 200)
    {
        try
        {
            switch ((int)_statusCode)
            {
                case 404:
                    await this.Handle404ErrorResponse(_httpRequest, _httpResponse);
                    break;
                default:
                    await this.HandleDefaultErrorResponse(_httpRequest, _httpResponse, (int)_statusCode);
                    break;
            }
        }
        catch (HttpRestException ex)
        {
            if (_shouldTrace)
            {
                ServiceClientTracing.Error(_invocationId, ex);
            }
            throw ex;
        }
    }
    ```
    where `Handle404ErrorResponse` would look like:
    ```csharp
    private async Task HandleErrorResponse<T>(HttpRequestMessage _httpRequest, HttpResponseMessage _httpResponse, string errorMessage) where T : HttpRestException
    {
        string _responseContent = null;
        _httpResponse.Content = new StringContent("{\"resName\":\"MyResource\"}");

        T ex = null;
        try
        {
            _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            ex = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<T>(_responseContent, Client.DeserializationSettings);
            ex.SetMessage(errorMessage);
        }
        catch (JsonException)
        {
            // Ignore the exception
        }

        if (ex == null)
        {
            ex = System.Activator.CreateInstance(typeof(T), new string[] { errorMessage }) as T;
        }

        ex.Request = new HttpRequestMessageWrapper(_httpRequest, null);
        ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
        _httpRequest.Dispose();
        if (_httpResponse != null)
        {
            _httpResponse.Dispose();
        }
        throw ex;
    }
    ```
    Note: `HttpRestException` is a generic base case for all exception classes as discussed in the section below. 
    Modelling the error model as the exception class itself allows us to cleanly deserialize the response object returned by the service and bubble up all the related information in the form of properties of the exception class itself (which is `ResourceName` for `NotFoundError`)

3.  Allowing Exception classes to inherit from custom base class implementations. 
    This enables customizations that can be shared between all exceptions thrown by service(s). The custom base class should ideally inherit from `HttpRestException` or contain the properties `HttpRequest`, `HttpResponse` and `message` along with constructors that sets these properties and an empty constructor for serialization purposes. This is a contract that custom base classes should adhere to in order to ensure AutoRest generated exception classes compile successfully.
    The HttpRestException base class is designed as below:
    ```csharp
    public abstract class HttpRestException : Exception
    {
        public HttpRequestMessageWrapper Request { get; set; }

        public HttpResponseMessageWrapper Response { get; set; }

        public HttpRestException()
        {
        }

        public HttpRestException(string message)
            : base(message, null)
        {
        }

        public HttpRestException(string message, System.Exception innerException)
        : base(message, innerException)
        {
        }

        private string _message;

        internal void SetMessage(string message) => this._message = message;

        public override string Message => this._message;
    }
    ```
    By default, all error models (exception classes) will inherit from `HttpRestException`.
    Custom base classes for specific classes can be explicitly defined in the configuration file using directives as below. It is left to the author to ensure that the assembly containing the base class is referenced accordingly at compile time and the base class has the same structure and functionalities as `HttpRestException`. 
    
    An example directive to specify custom base class is as below:
    ```javascript
    directive:
        from: code-model-v1
        where: $.modelTypes[?(@.name.raw=='NotFoundError')]
        transform: >
            const baseType = {
                "properties":{

                },
                "name":{
                    "fixed":false
                    "raw":"CustomBaseException"
                },
                "extensions":{
                    "x-ms-external":true
                }
            };
            $.baseModelType = JSON.stringify(baseType);
        reason: We want to model our own base classes
    ```
    The code generated will substitute `HttpRestException` with `CustomBaseException` in the code above. This can be extended to non-error models too.